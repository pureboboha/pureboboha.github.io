<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>其他动态规划问题</title>
    <link href="/2022/03/23/%E5%85%B6%E4%BB%96%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/23/%E5%85%B6%E4%BB%96%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="打家劫舍、LIS、LCS"><a href="#打家劫舍、LIS、LCS" class="headerlink" title="打家劫舍、LIS、LCS"></a>打家劫舍、LIS、LCS</h1><h2 id="一、打家劫舍"><a href="#一、打家劫舍" class="headerlink" title="一、打家劫舍"></a>一、打家劫舍</h2><p><strong>题目描述</strong>：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p><strong>分析</strong>：抽象出子问题：<br><img src="https://s2.loli.net/2022/03/24/NCw3tySHh5r6X1i.png"><br>写出状态转移方程：dp[i]=max(dp[i-1],dp[i-2]+nums[i])<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(!nums.size())return 0;</span><br><span class="line">        if(nums.size()==1)return nums[0];</span><br><span class="line">       vector&lt;int&gt; dp(nums.size());</span><br><span class="line">       dp[0]=nums[0];</span><br><span class="line">       dp[1]=max(nums[1],nums[0]);</span><br><span class="line">     for(int i=2;i&lt;nums.size();i++)&#123; </span><br><span class="line">       dp[i]=max(dp[i-2]+nums[i],dp[i-1]);</span><br><span class="line">     &#125;</span><br><span class="line">    return dp[nums.size()-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>问题升级：假设所有的房子是收尾相连的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">      vector&lt;int&gt; dp;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(!nums.size())return 0;</span><br><span class="line">        if(nums.size()==1)return nums[0];</span><br><span class="line">        if(nums.size()==2)return max(nums[0],nums[1]);</span><br><span class="line">        dp.resize(nums.size());</span><br><span class="line">        int res=0;  </span><br><span class="line">        res=max(robwho(nums,0,nums.size()-2),robwho(nums,1,nums.size()-1));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    int robwho(vector&lt;int&gt;&amp; nums,int n,int m)&#123; </span><br><span class="line">        dp[n]=nums[n];</span><br><span class="line">        dp[n+1]=max(nums[n],nums[n+1]);        </span><br><span class="line">        for(int i=n+2;i&lt;=m;i++)&#123;</span><br><span class="line">            dp[i]=max(dp[(i-2)]+nums[i],dp[i-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、LIS"><a href="#二、LIS" class="headerlink" title="二、LIS"></a>二、LIS</h2><p><strong>题目描述</strong>：求一串整形数组的最长非降子序列。</p><p><strong>分析</strong>：假设dp[i] = j，i表示取序列的前i个数，j表示这前i个数字的最长非降序列的长度。dp[i] = max{ 1,  dp[j]+1} ,且满足当i &gt; j时，A[i] &gt;= A[j]。<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 100;</span><br><span class="line">int A[N], dp[N], n;// 序列和, dp数组, 数字总数</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  for(int i=1; i &lt;= n; i++) &#123;</span><br><span class="line">    cin&gt;&gt;A[i];</span><br><span class="line">  &#125;// 从 1 ～ N 编号</span><br><span class="line">  int ans = -1;// 记录最大的 dp[i]</span><br><span class="line">  for(int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i] = 1;// 至少能够自身成为一条 LIS</span><br><span class="line">    for(int j = 1; j &lt; i; j++)&#123;// 只需要递归到小于 i</span><br><span class="line">      // 如果不比之前的小，而且新形成的子序列更大，则接到这个人后面来</span><br><span class="line">      if(A[i] &gt;= A[j]) &#123;</span><br><span class="line">        dp[i] = max(dp[i],dp[j]+1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = max(ans, dp[i]);// 确定当前结束的最长子序列的长度之后，比较</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、LCS"><a href="#三、LCS" class="headerlink" title="三、LCS"></a>三、LCS</h2><p><strong>题目描述</strong>：求两个字符串的最长公共子序列。</p><p><strong>分析</strong>：同理先分析子问题：<br><img src="https://s2.loli.net/2022/03/24/FVlKvoT7N13EgZa.png"><br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void lcs(string s1, string s2)</span><br><span class="line">&#123;</span><br><span class="line">    for(i=1; i&lt;=s1.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=1; j&lt;=s2.length(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">          dp[i][j]=max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">          if(s1[i-1]==s2[j-1])&#123;</span><br><span class="line">              dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>三种背包问题</title>
    <link href="/2022/03/15/%E4%B8%89%E7%A7%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/15/%E4%B8%89%E7%A7%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划之三种背包问题"><a href="#动态规划之三种背包问题" class="headerlink" title="动态规划之三种背包问题"></a>动态规划之三种背包问题</h1><h2 id="一、01背包"><a href="#一、01背包" class="headerlink" title="一、01背包"></a>一、01背包</h2><p><strong>题目介绍</strong>：<br>有 N 件物品和一个容量为 V 的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。</p><p><strong>解析</strong>：<br>首先听名字为什么叫01背包问题呢，就是指每件物品都有两种状态：选择和不选择，所以如果采用暴力搜索，就是将所有的情况枚举出来一一比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int v[500];    // 体积</span><br><span class="line">int w[500];    // 价值 </span><br><span class="line">int volume[500];</span><br><span class="line">int value[500];</span><br><span class="line">int res = 0;</span><br><span class="line">int n, m;</span><br><span class="line">void bs(int k) &#123;</span><br><span class="line">    if (k &gt; n) &#123;</span><br><span class="line">        int vol = 0;</span><br><span class="line">        int val = 0;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            vol += volume[i];</span><br><span class="line">            val += value[i];</span><br><span class="line">        &#125;</span><br><span class="line">        if (vol &lt;= m &amp;&amp; val &gt; res) &#123;</span><br><span class="line">            res = val;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt;= 1; i++) &#123;</span><br><span class="line">        volume[k] = v[k] * i;</span><br><span class="line">        value[k] = w[k] * i;</span><br><span class="line">        bs(k + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    bs(1);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但这样的算法时间复杂度为2的n次方，显然会超时，应此应当采用动态规划的解法。</p><p>动态规划的解法有两种思路，开辟二维数组和一维数组都能做，首先来讲最基本的二维数组法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int v[500];    // 体积</span><br><span class="line">int w[500];    // 价值 </span><br><span class="line">int dp[500][500];  // f[i][j], j体积下前i个物品的最大价值 </span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    int n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) </span><br><span class="line">        for(int j = 1; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span><br><span class="line">            if(j &lt; v[i]) </span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">            // 能装，需进行决策是否选择第i个物品</span><br><span class="line">            else    </span><br><span class="line">                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于二维数组可以记录所有状态(前i个物品*j体积)下的最大价值，应此可以采用正序更新状态，但是如果将其转化为一维数组，正序更新状态可能会出现问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int v[500];    // 体积</span><br><span class="line">int w[500];    // 价值 </span><br><span class="line">int dp[500];  // dp[j], j体积下的最大价值 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        for (int j = m; j &gt;= v[i]; j--)</span><br><span class="line">            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是为什么呢，其实一维数组正序在更新状态时，即在<code>dp[j] = max(dp[j], dp[j - v[i]] + w[i])</code>这一步，dp[j-v[i]]可能是前i-1个物品的状态，也可能是前i个物品的状态，如果是前i个物品的状态，更新就出问题了。因为依照01背包更新状态的原则，应当斜线更新状态。</p><h2 id="二、完全背包"><a href="#二、完全背包" class="headerlink" title="二、完全背包"></a>二、完全背包</h2><p><strong>题目介绍</strong>：<br>有 N 件物品和一个容量为 V 的背包，每件物品有各自的价值且可以被选择多次，要求在有限的背包容量下，装入的物品总价值最大。</p><p><strong>解析</strong>：<br>不难发现，完全背包问题和01背包问题的区别仅仅在于物品可以放很多次，所以我们直接上代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int v[500];    // 体积</span><br><span class="line">int w[500];    // 价值 </span><br><span class="line">int dp[500][500];  // f[i][j], j体积下前i个物品的最大价值 </span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    int n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) </span><br><span class="line">        for(int j = 1; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(j &lt; v[i]) </span><br><span class="line">                dp[i][j] = dp[i - 1][j];</span><br><span class="line">            else    </span><br><span class="line">            //区别就在这一步：完全背包更新状态的规则为横线更新</span><br><span class="line">                dp[i][j] = max(dp[i - 1][j], dp[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、"><a href="#三、" class="headerlink" title="三、"></a>三、</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BFS</title>
    <link href="/2022/03/11/BFS/"/>
    <url>/2022/03/11/BFS/</url>
    
    <content type="html"><![CDATA[<h1 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h1><p><img src="https://s2.loli.net/2022/03/12/KXcoqju8nEsh1Zk.png"><br>典型案例：</p><p><strong>1、求最短路问题(走迷宫问题)</strong></p><p>例：给定一个n*m的二维整数数组，用来表示一个迷宫，数组只包含0和1，1表示可走，0表示不可走。<br>求一个人从(1,1)走到(n,m)至少需要移动几次。注：他一次只能上下左右移动一格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int m, n;</span><br><span class="line">struct node &#123;</span><br><span class="line">int x, y;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">//迷宫布局</span><br><span class="line">int a[500][500];</span><br><span class="line">//记录有无被访问</span><br><span class="line">int st[500][500];</span><br><span class="line">//记录步数</span><br><span class="line">int ans[500][500];</span><br><span class="line">//定义移动向量</span><br><span class="line">int dx[] = &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] = &#123; 0,0,1,-1 &#125;;</span><br><span class="line">void bfs() &#123;</span><br><span class="line">q.push(&#123; 1,1 &#125;);</span><br><span class="line">st[1][1] = 1;</span><br><span class="line">while (q.size()) &#123;</span><br><span class="line">node t = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">int xx = t.x;</span><br><span class="line">int yy = t.y;</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">int x = xx + dx[i];</span><br><span class="line">int y = yy + dy[i];</span><br><span class="line">if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; n || st[x][y] || a[x][y] == 1) continue;</span><br><span class="line">q.push(&#123; x,y &#125;);</span><br><span class="line">ans[x][y] = ans[xx][yy] + 1;</span><br><span class="line">st[x][y] = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[1][1] = 0;</span><br><span class="line">memset(ans, 0x3f, sizeof ans);</span><br><span class="line">memset(st, 0, sizeof st);</span><br><span class="line">bfs();</span><br><span class="line">cout &lt;&lt; ans[n][m] &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>拓展例题加深：</em></p><p>小明在玩一款迷宫游戏，在游戏中他要控制自己的角色离开一间由 N×N 个格子组成的 2D 迷宫。<br>小明的起始位置在左上角，他需要到达右下角的格子才能离开迷宫。<br>每一步，他可以移动到上下左右相邻的格子中（前提是目标格子可以经过）。<br>迷宫中有些格子小明可以经过，我们用 ‘.’ 表示。<br>有些格子是墙壁，小明不能经过，我们用 ‘#’ 表示。<br>此外，有些格子上有陷阱，我们用 ‘X’ 表示。除非小明处于无敌状态，否则不能经过。<br>有些格子上有无敌道具，我们用 ‘%’ 表示。<br>当小明第一次到达该格子时，自动获得无敌状态，无敌状态会持续 K 步。<br>之后如果再次到达该格子不会获得无敌状态了。<br>处于无敌状态时，可以经过有陷阱的格子，但是不会拆除/毁坏陷阱，即陷阱仍会阻止没有无敌状态的角色经过。<br>给定迷宫，请你计算小明最少经过几步可以离开迷宫?<br><em>解析：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">char a[1100][1100];</span><br><span class="line">int ans[1100][1100];</span><br><span class="line">int sign[1100][1100];</span><br><span class="line">int value[1100][1100];</span><br><span class="line">//由于本题在无敌状态下可以重复走相同的点，应此不能用标记法记录已走过的点，而是采用比较节点的步数和当前已标记步数sign[x][y]的大小。当处于无敌状态时，又开启另外一种状态。</span><br><span class="line">struct node &#123;</span><br><span class="line">int x, y, flag, step;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt;q;</span><br><span class="line">int dx[] = &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] = &#123; 0,0,1,-1 &#125;;</span><br><span class="line">int w = 0;</span><br><span class="line">int k;</span><br><span class="line">int bfs() &#123;</span><br><span class="line">while (q.size()) &#123;</span><br><span class="line">node t = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">int xx = t.x;</span><br><span class="line">int yy = t.y;</span><br><span class="line">int flag = t.flag;</span><br><span class="line">int step = t.step;</span><br><span class="line">if (xx == n &amp;&amp; yy == n)</span><br><span class="line">return step;</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">int x = xx + dx[i];</span><br><span class="line">int y = yy + dy[i];</span><br><span class="line">if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; n || a[x][y] == &#x27;#&#x27;)continue;</span><br><span class="line">if (a[x][y] == &#x27;.&#x27;) &#123;</span><br><span class="line">if (step + 1 &lt; sign[x][y] || flag - 1 &gt; value[x][y]) &#123;</span><br><span class="line">          sign[x][y] = step + 1;</span><br><span class="line">  //注意这里不能改变flag的值，以防下一次循环出现问题</span><br><span class="line">          int flag1=flag;</span><br><span class="line">if (flag &gt; 0) &#123;</span><br><span class="line">flag1=flag-1;</span><br><span class="line">&#125;</span><br><span class="line">value[x][y] = flag1;</span><br><span class="line">q.push(&#123; x,y,flag1,step + 1 &#125;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (a[x][y] == &#x27;X&#x27; &amp;&amp; flag &gt; 0) &#123;</span><br><span class="line">if (step + 1 &lt; sign[x][y] || flag - 1 &gt; value[x][y]) &#123;</span><br><span class="line">sign[x][y] = step + 1;</span><br><span class="line">value[x][y] = flag - 1;</span><br><span class="line">q.push(&#123; x,y,flag - 1,step + 1 &#125;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (a[x][y] == &#x27;%&#x27;) &#123;</span><br><span class="line">if (step + 1 &lt; sign[x][y]) &#123;</span><br><span class="line">sign[x][y] = step + 1;</span><br><span class="line">value[x][y] = k;</span><br><span class="line">q.push(&#123; x, y, k, step + 1 &#125;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q.push(&#123; 1,1,0,0 &#125;);</span><br><span class="line">ans[1][1] = 0;</span><br><span class="line">memset(sign, 0x3f3f3f3f, sizeof sign);</span><br><span class="line">memset(value, 0, sizeof value);</span><br><span class="line">cout &lt;&lt; bfs() &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、求连通块问题(岛屿淹没问题)</strong></p><p>例：有一个N*N的海域像素照片，”·”表示海域，”#”表示陆地，其中上下左右四个方向连在一起的陆地称为岛屿。</p><p>问题1：先给定一片海域，求出岛屿的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">char s[500][500];</span><br><span class="line">int st[500][500];</span><br><span class="line">int dx[] = &#123; -1,1,0,0 &#125;;</span><br><span class="line">int dy[] = &#123; 0,0,1,-1 &#125;;</span><br><span class="line">struct node &#123;</span><br><span class="line">int x, y;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">int cnt = 0;</span><br><span class="line">void bfs() &#123;</span><br><span class="line">while (q.size()) &#123;</span><br><span class="line">node t = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">int x = t.x + dx[i];</span><br><span class="line">int y = t.y + dy[i];</span><br><span class="line">if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; n || st[x][y] || s[x][y] == &#x27;.&#x27;)continue;</span><br><span class="line">q.push(&#123; x,y &#125;);</span><br><span class="line">st[x][y] = 1;</span><br><span class="line">s[x][y] = &#x27;.&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; s[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">if (s[i][j] == &#x27;#&#x27;) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">q.push(&#123; i,j &#125;);</span><br><span class="line">s[i][j] = &#x27;.&#x27;;</span><br><span class="line">st[i][j] = 1;</span><br><span class="line">bfs();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题2：随着海平面上升，上下左右有海的陆地会被淹没，求最终被完全吞没的岛屿数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">char s[500][500];</span><br><span class="line">int st[500][500];</span><br><span class="line">int dx[] = &#123; -1,1,0,0 &#125;;</span><br><span class="line">int dy[] = &#123; 0,0,1,-1 &#125;;</span><br><span class="line">struct node &#123;</span><br><span class="line">int x, y;</span><br><span class="line">&#125;;</span><br><span class="line">int cnt = 0;</span><br><span class="line">void bfs(int a,int b) &#123;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">st[a][b] = 1;</span><br><span class="line">q.push(&#123; a,b &#125;);</span><br><span class="line">int tot = 0;</span><br><span class="line">while (q.size()) &#123;</span><br><span class="line">node t = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">tot++;</span><br><span class="line">bool ju = false;</span><br><span class="line">for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">int x = t.x + dx[i];</span><br><span class="line">int y = t.y + dy[i];</span><br><span class="line">if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; n || st[x][y])continue;</span><br><span class="line">if (s[x][y] == &#x27;#&#x27;) &#123;</span><br><span class="line">q.push(&#123; x,y &#125;);</span><br><span class="line">st[x][y] = 1;</span><br><span class="line">s[x][y] = &#x27;.&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">else ju = true;</span><br><span class="line">&#125;</span><br><span class="line">if (ju)tot--;</span><br><span class="line">&#125;</span><br><span class="line">if (tot == 0)cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; s[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">if (s[i][j] == &#x27;#&#x27;) &#123;</span><br><span class="line">bfs(i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//7</span><br><span class="line">//.......</span><br><span class="line">//.##....</span><br><span class="line">//.##....</span><br><span class="line">//....##.</span><br><span class="line">//..####.</span><br><span class="line">//...###.</span><br><span class="line">//.......</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DFS</title>
    <link href="/2022/03/10/DFS/"/>
    <url>/2022/03/10/DFS/</url>
    
    <content type="html"><![CDATA[<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><h2 id="解题模板："><a href="#解题模板：" class="headerlink" title="解题模板："></a>解题模板：</h2><p><img src="https://s2.loli.net/2022/03/11/b6mqraOg9SCZMl5.png" alt="dfs"></p><h2 id="应用案例："><a href="#应用案例：" class="headerlink" title="应用案例："></a>应用案例：</h2><p>1、全排列问题</p><p>例：按照字典序输出自然数1到n所有不重复的排列，要求所产生的任意一数字序列中不允许出现重复数字。</p><p>常规做法：用C++内置排序算法：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;algorithm&gt;</span><br><span class="line">bool next_permutation(iterator start,iterator end)</span><br></pre></td></tr></table></figure><br>当当前序列不存在下一个排列时，函数返回false，否则返回true。</p><p>具体实现方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int a[101];</span><br><span class="line">for (int i = 1; i &lt;=n; i++) &#123;</span><br><span class="line">a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">do &#123;</span><br><span class="line">for (int i = 1; i &lt;=n; i++) &#123;</span><br><span class="line">cout &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125; while (next_permutation(a + 1, a + n + 1));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若改成dfs算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int st[101];</span><br><span class="line">int ans[101];</span><br><span class="line">void dfs(int x) &#123;</span><br><span class="line">if (x &gt; n) &#123;</span><br><span class="line">for (int i = 1; i &lt;=n; i++) &#123;</span><br><span class="line">cout &lt;&lt; ans[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;=n; i++) &#123;</span><br><span class="line">if (st[i] == 0) &#123;</span><br><span class="line">st[i] = 1;</span><br><span class="line">ans[x] = i;</span><br><span class="line">dfs(x + 1);</span><br><span class="line">st[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">memset(st, 0, sizeof(st));</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">dfs(1);</span><br><span class="line">return 0;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然上半部分作为枚举出来的各种情况可以被使用来完成当前题目要求，例如有这么一道题：输入一个整数，将其改为带分数的形式，并且满足特征：带分数中数字1-9分别并且只出现一次，统计所有表示方法；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int st[101];</span><br><span class="line">int ans[101];</span><br><span class="line">int cnt = 0;</span><br><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">int x = 0;</span><br><span class="line">for (int i = m; i &lt;= n; i++) &#123;</span><br><span class="line">x *= 10;</span><br><span class="line">x += ans[i];</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x) &#123;</span><br><span class="line">if (x &gt; 9) &#123;</span><br><span class="line">for (int i = 1; i &lt;= 7; i++) &#123;</span><br><span class="line">for (int j = i + 1; j &lt;= 8;j++) &#123;</span><br><span class="line">int a = cal(1, i);</span><br><span class="line">int b = cal(i + 1, j);</span><br><span class="line">int c = cal(j + 1, 9);</span><br><span class="line">if (n * c == a * c + b) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;=9; i++) &#123;</span><br><span class="line">if (st[i] == 0) &#123;</span><br><span class="line">st[i] = 1;</span><br><span class="line">ans[x] = i;</span><br><span class="line">dfs(x + 1);</span><br><span class="line">st[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">memset(st, 0, sizeof(st));</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">dfs(1);</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、n皇后问题</p><p>&emsp;&emsp;n个皇后放在n*n的国际象棋棋盘上，使得皇后不能互相攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现给定整数n，输出所有所有满足条件的棋子摆法。输出的每一行中有皇后的位置用”·”表示，皇后的位置用”Q”表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int st[11];</span><br><span class="line">int stx[11];</span><br><span class="line">int stfx[11];</span><br><span class="line">int ans[50][50];</span><br><span class="line">void dfs(int x) &#123;</span><br><span class="line">if (x &gt; n) &#123;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">if (ans[i][j] == 1)cout &lt;&lt; &quot;Q&quot;;</span><br><span class="line">else cout &lt;&lt; &quot;·&quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">if (st[i] == 0 &amp;&amp; stx[x - i + 10] == 0 &amp;&amp; stfx[x + i + 10] == 0) &#123;</span><br><span class="line">st[i] = 1;</span><br><span class="line">stx[x - i + 10] = 1;</span><br><span class="line">stfx[x + i + 10] = 1;</span><br><span class="line">ans[x][i] = 1;</span><br><span class="line">dfs(x + 1);</span><br><span class="line">ans[x][i] = 0;</span><br><span class="line">st[i] = 0;</span><br><span class="line">stx[x - i + 10] = 0;</span><br><span class="line">stfx[x + i + 10] = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">memset(st, 0, sizeof(st));</span><br><span class="line">memset(stx, 0, sizeof(stx));</span><br><span class="line">memset(stfx, 0, sizeof(stfx));</span><br><span class="line">memset(ans, 0, sizeof(ans));</span><br><span class="line">dfs(1);</span><br><span class="line">return 0;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里要注意，每次清理上一次枚举的空间时要清理干净，如果不确定哪些空间是一定要清理的，不妨所有的空间全部清理，即全部置0。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>innerHTML的秘密</title>
    <link href="/2022/02/18/innerHTML%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <url>/2022/02/18/innerHTML%E7%9A%84%E7%A7%98%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="innerHTML易错"><a href="#innerHTML易错" class="headerlink" title="innerHTML易错"></a>innerHTML易错</h1><h4 id="emsp-emsp-在一次用原生js写的项目中拿到后端的数据用mapAPI对页面进行渲染的时候发现明明是一模一样代码，都能选中特点的节点为之绑定单击响应事件，只是放的位置不同，怎么前者就绑定不成功呢。"><a href="#emsp-emsp-在一次用原生js写的项目中拿到后端的数据用mapAPI对页面进行渲染的时候发现明明是一模一样代码，都能选中特点的节点为之绑定单击响应事件，只是放的位置不同，怎么前者就绑定不成功呢。" class="headerlink" title="&emsp;&emsp;在一次用原生js写的项目中拿到后端的数据用mapAPI对页面进行渲染的时候发现明明是一模一样代码，都能选中特点的节点为之绑定单击响应事件，只是放的位置不同，怎么前者就绑定不成功呢。"></a>&emsp;&emsp;在一次用原生js写的项目中拿到后端的数据用mapAPI对页面进行渲染的时候发现明明是一模一样代码，都能选中特点的节点为之绑定单击响应事件，只是放的位置不同，怎么前者就绑定不成功呢。</h4><p><img src="https://s2.loli.net/2022/02/18/ZaKbJfmB6CUI3eh.png" alt="img1"></p><h4 id="emsp-emsp-更奇怪的是二者的’console-log-commend-index-’在控制台打印出来的内容是一样的，但是无意间发现后者鼠标放在输出的内容上，在网页上会出现标记（如图）。"><a href="#emsp-emsp-更奇怪的是二者的’console-log-commend-index-’在控制台打印出来的内容是一样的，但是无意间发现后者鼠标放在输出的内容上，在网页上会出现标记（如图）。" class="headerlink" title="&emsp;&emsp;更奇怪的是二者的’console.log(commend[index])’在控制台打印出来的内容是一样的，但是无意间发现后者鼠标放在输出的内容上，在网页上会出现标记（如图）。"></a>&emsp;&emsp;更奇怪的是二者的’console.log(commend[index])’在控制台打印出来的内容是一样的，但是无意间发现后者鼠标放在输出的内容上，在网页上会出现标记（如图）。</h4><p><img src="https://s2.loli.net/2022/02/18/2UCyzRqxZw8QLjF.png" alt="img2"></p><h4 id="emsp-emsp-这不是元素节点高亮吗-而前者就像纯文本那样没有反应，于是便想到可能是节点没有绑定成功，能获取但无法绑定？这怎么可能呢，百思不得其解，就去MDN上查了一下innerHTML，果然发现了问题！"><a href="#emsp-emsp-这不是元素节点高亮吗-而前者就像纯文本那样没有反应，于是便想到可能是节点没有绑定成功，能获取但无法绑定？这怎么可能呢，百思不得其解，就去MDN上查了一下innerHTML，果然发现了问题！" class="headerlink" title="&emsp;&emsp;这不是元素节点高亮吗,而前者就像纯文本那样没有反应，于是便想到可能是节点没有绑定成功，能获取但无法绑定？这怎么可能呢，百思不得其解，就去MDN上查了一下innerHTML，果然发现了问题！"></a>&emsp;&emsp;这不是元素节点高亮吗,而前者就像纯文本那样没有反应，于是便想到可能是节点没有绑定成功，能获取但无法绑定？这怎么可能呢，百思不得其解，就去MDN上查了一下innerHTML，果然发现了问题！</h4><p><img src="https://s2.loli.net/2022/02/18/9c3QqXzWE1RrGwM.png"></p><h4 id="emsp-emsp-原来innerHTML每渲染一次就会先删除原先的内容那么之前绑定过点击响应事件的元素节点不都已经被删除了吗，原来如此！！！"><a href="#emsp-emsp-原来innerHTML每渲染一次就会先删除原先的内容那么之前绑定过点击响应事件的元素节点不都已经被删除了吗，原来如此！！！" class="headerlink" title="&emsp;&emsp;原来innerHTML每渲染一次就会先删除原先的内容那么之前绑定过点击响应事件的元素节点不都已经被删除了吗，原来如此！！！"></a>&emsp;&emsp;原来innerHTML每渲染一次就会先删除原先的内容那么之前绑定过点击响应事件的元素节点不都已经被删除了吗，原来如此！！！</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯真题01</title>
    <link href="/2022/01/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%9801/"/>
    <url>/2022/01/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%9F%E9%A2%9801/</url>
    
    <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>&emsp;&emsp;小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组 成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。</p><p>&emsp;&emsp;现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这 个字母出现的次数。</p><p><strong>输入描述：</strong></p><p>输入一行包含一个单词，单词只由小写英文字母组成。</p><p>对于所有的评测用例，输入的单词长度不超过 1000。</p><p><strong>输出描述：</strong></p><p>输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪 个。如果有多个字母出现的次数相等，输出字典序最小的那个。</p><p>第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。</p><p><strong>分析：</strong></p><p>&emsp;&emsp;这是一道字符串的暴力求解类题目，我的做法时间复杂度为O(n^2)，源代码在GitHub库中有，这里总结了两个值得注意的地方：1、对于循环外的变量如果作为判断（bool类型），在每次循环后记得恢复初值。2、作为竞赛进行调试的时候，要挑选多个最简单的错例，记得考虑边界情况。下面给出一种时间复杂度仅为O(n)的解法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  string a;</span><br><span class="line">  cin&gt;&gt;a;int max=0;</span><br><span class="line">  int c[26];</span><br><span class="line">  int i;int b=97;char x;</span><br><span class="line">  for(i=0;i&lt;a.length();++i)</span><br><span class="line">  &#123;</span><br><span class="line">    ++c[a[i]-97];//利用ASK码将字符转化为数组的特定的下标，这样就省了开辟两个数组，一个用来放字符，一个用来放该字符出现的次数。也是这种解法的绝妙之处；</span><br><span class="line">  &#125;</span><br><span class="line">  for(i=0;i&lt;26;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    if(c[i]&gt;max)&#123;</span><br><span class="line">      max=c[i];</span><br><span class="line">      x=i+97;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;x&lt;&lt;endl&lt;&lt;max&lt;&lt;endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS01</title>
    <link href="/2022/01/15/CSS01/"/>
    <url>/2022/01/15/CSS01/</url>
    
    <content type="html"><![CDATA[<h1 id="论inline-block你可能不知道的秘密"><a href="#论inline-block你可能不知道的秘密" class="headerlink" title="论inline-block你可能不知道的秘密"></a>论inline-block你可能不知道的秘密</h1><p>&emsp;&emsp;说到“display：inline-block”；想必大家都不陌生，把一个块级元素或者是行内元素变成一个行内块元素有很多优点，可以在设置的宽高的同时实现元素的并排布局。然而，你可能并没有发现行内块元素存在的两个小秘密，在某种程度上也可以说是小bug。</p><h3 id="1、行内块元素之间的缝隙问题"><a href="#1、行内块元素之间的缝隙问题" class="headerlink" title="1、行内块元素之间的缝隙问题"></a>1、行内块元素之间的缝隙问题</h3><p>&emsp;&emsp;很多时候，你会发现行内块元素在并排布局的时候元素之间是会出现小缝隙的，这是由于你在书写HTML的时候打了换行产生的，怎么解决这个问题呢，最好的方法就是给这两个元素的父级元素添加“font-size：0；”这个样式，当然在书写HTML的时候不换行也是一种做法，但是这么做会影响阅读效果，不推荐。</p><h3 id="2、行内块元素的对齐问题"><a href="#2、行内块元素的对齐问题" class="headerlink" title="2、行内块元素的对齐问题"></a>2、行内块元素的对齐问题</h3><p>&emsp;&emsp;这个问题可能是大多数人不怎么关注的问题，但是你有没有遇到过这种情况，当你给input标签设置宽高时，它总是与其他行内块元素无法正常对齐。<br>&emsp;&emsp;其实行内块元素的对齐方式有以下三种情况：1、二者内都没有文字：底部对齐；2、其中一者有文字：文字和另外一者底部对齐；3、二者内都有文字：文字和文字对齐。所以上面提到的input标签之所以设置高度后和其他行内块元素对齐时那么奇怪就是因为input标签是默认有垂直居中文字的行内块元素。</p><h2 id="那么问题来了，为什么不用float？"><a href="#那么问题来了，为什么不用float？" class="headerlink" title="那么问题来了，为什么不用float？"></a>那么问题来了，为什么不用float？</h2><p>&emsp;&emsp;实际上，浮动确实能解决行内块元素存在的这两个问题，但是浮动的发明初衷是为了解决文字环绕问题的，为了不再被过多得滥用，我们尽量让它发挥他真正的用途，此外，用float进行布局很肯能会导致布局混乱、元素被遮盖等问题，因此我们还是要慎用float。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS02</title>
    <link href="/2022/01/15/CSS02/"/>
    <url>/2022/01/15/CSS02/</url>
    
    <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><h2 id="一、什么是BFC？"><a href="#一、什么是BFC？" class="headerlink" title="一、什么是BFC？"></a>一、什么是BFC？</h2><p>&emsp;&emsp;BFC的全称是Block Formatting Contexts，即块级格式化上下文，它属于定位普通流。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。通俗一点来讲，可以把 BFC 理解为一个<strong>封闭的大箱子</strong>，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p><h2 id="二、怎么开启BFC？"><a href="#二、怎么开启BFC？" class="headerlink" title="二、怎么开启BFC？"></a>二、怎么开启BFC？</h2><p>只要元素满足下面任一条件即可触发 BFC 特性：</p><p>1、body 根元素</p><p>2、浮动元素：float 除 none 以外的值</p><p>3、绝对定位元素：position (absolute、fixed)</p><p>4、display 为 inline-block、table-cells、flex</p><p>5、overflow 除了 visible 以外的值 (hidden、auto、scroll)</p><p>6、display：flow-root；</p><h2 id="三、BFC的实际应用"><a href="#三、BFC的实际应用" class="headerlink" title="三、BFC的实际应用"></a>三、BFC的实际应用</h2><p>1、解决上下两个div外边距重叠问题</p><p>2、清除浮动，解决拥有浮动元素的div的高度塌陷问题：浮动元素不属于文档中的普通流，当一个元素浮动之后，不会影响到块级元素的布局而只会影响内联元素（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样，当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）,正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度。</p><p>3、解决第一个子元素设置margin-top父元素会跟着移动问题</p><p>4、解决被浮动元素遮盖的问题：开启BFC的元素，子元素和父元素的外边距不会重叠</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划例题剖析</title>
    <link href="/2022/01/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BE%8B%E9%A2%98%E5%89%96%E6%9E%90/"/>
    <url>/2022/01/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BE%8B%E9%A2%98%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h1><p><strong>题目描述</strong></p><p>&emsp;&emsp;给出不同面额的硬币以及一个总金额。写一个方法来计算给出的总金额可以换取的最少的硬币数量。 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回-1。</p><p><strong>分析</strong></p><p>一、莫入误区</p><p>&emsp;&emsp;很多人初看这道题就会以为是贪心算法类题目，在这里我们举个例子，假设硬币的面额分别为2、5、7，总金额为27，如果按照贪心算法，我们会先选择面额大的7，然后再选择5和2，你的结果将会是7+7+7+2+2+2，最少硬币数为6，然而正确答案为7+5+5+5+5，仅用了5个硬币。举其他例子，也会有这样的反例，因此这道题并不能用贪心算法来做，这是一道典型的求最值型动态规划题。</p><p>二、动态规划四部曲</p><p>1、确定状态</p><p>&emsp;&emsp;状态在动态规划中的作用属于定海神针，简单的来说，解动态规划题的时候需要开辟一个数组，要理解数组的每个元素f[i]或者f[i][j]代表什么（类似于数学题中的X,Y,Z代表什么）。确定状态需要两个意识：<strong>最后一步、子问题</strong>。</p><p>&emsp;&emsp;本题的最后一步：虽然我们不知道最优策略是什么，但是最优策略肯定是K枚硬币a1，a2，…ak面值加起来是27，所以一定有一枚<strong>最后</strong>的硬币：ak。除掉这枚硬币，前面的硬币的面值加起来是27-ak。</p><p>&emsp;&emsp;<strong>关键点1</strong>：我们不关心前面的k-1枚硬币是怎么拼出27-ak的（无论有几种拼法），而且我们现在也不知道ak和k，但是我们确定前面的硬币拼出了27-ak。</p><p>&emsp;&emsp;<strong>关键点2</strong>：因为是最优策略，所以拼出27-ak的硬币数一定最少，否则就不是最优策略了。</p><p>&emsp;&emsp;本题的子问题由此而生：最少用多少枚硬币可以拼出27-ak。为了简化定义，我们设状态<strong>f(X)=最少用多少枚硬币拼出X</strong>。</p><p>2、转移方程</p><p>&emsp;&emsp;由于需要求最少的硬币数，所以我们可以列出递推式：**f(X)=min{f(X-a1)+1,f(X-a2)+1,…,f(X-ak)+1}**。</p><p>&emsp;&emsp;其实想到这里，我们已经能写出递归函数解决这道题目了，只要加上一些递归出的条件：很明显只有当X&gt;ak时才能做f(X-ak)+1这步操作，再加上f(0)=0，我们便能得到递归函数(用之前的例子)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int f(int X)</span><br><span class="line">&#123;</span><br><span class="line">    if(X==0)return 0;</span><br><span class="line">    if(X&gt;=2)&#123;</span><br><span class="line">        res=Math.min(f(X-2)+1，res);</span><br><span class="line">    &#125;</span><br><span class="line">    if(X&gt;=5)&#123;</span><br><span class="line">        res=Math.min(f(X-5)+1,res);</span><br><span class="line">    &#125;</span><br><span class="line">    if(X&gt;=7)&#123;</span><br><span class="line">        res=Math.min(f(X-7)+1,res);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;递归函数的问题：递归算法的时间复杂度一般都是指数型的，原因是它做了很多的重复计算，效率比较低，怎么解决这个问题呢，我们就想能不能将<strong>每次计算的结果保留下来</strong>，类似于做一个备忘录的效果，并且<strong>改变计算顺序</strong>。</p><p>3、初始化dp数组</p><p>&emsp;&emsp;为了保留计算结果，我们需要开辟一个dp数组，并且需要根据不同的题目初始化这个数组，在本题中由于要求最小硬币数，所以我们可以将数组中的值初始化为正无穷。</p><p>&emsp;&emsp;再考虑一些边界情况，如果X-ak&lt;0，即拼不出来，我们也令这些值为正无穷。</p><p>4、计算顺序</p><p>&emsp;&emsp;在动态规划类题目中尝尝需要我们反着计算，这道题就是如此，我们先从小的数开始计算，从1、2…一直算到给定的目标数，这样后面较大的数可以利用前面较小数的计算结果。</p><p><strong>解答：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">     int coinChange(vector&lt;int&gt;&amp; coins, int amount)&#123;</span><br><span class="line">        vector&lt;int&gt; f(amount+1);</span><br><span class="line">        int i,j;</span><br><span class="line">        f[0] = 0;//初始化只让总金额为0的方案可行且用的硬币数为0</span><br><span class="line">        for(i=1;i&lt;=amount;++i)&#123;</span><br><span class="line">            f[i]=-1;</span><br><span class="line">            for(j=0;j&lt;coins.size();++j)&#123;</span><br><span class="line">                if(i&gt;=coins[j] &amp;&amp; f[i-coins[j]]!=-1)&#123;</span><br><span class="line">                    if(f[i]==-1 || f[i-coins[j]]+1&lt;f[i])&#123;</span><br><span class="line">                        f[i]=f[i-coins[j]]+1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>&emsp;&emsp;以上代码我们不难发现，动态规划很好得避免了重复计算，把时间复杂度从指数降到了n方，从而达到了算法题的规定。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大数运算03</title>
    <link href="/2022/01/13/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%9703/"/>
    <url>/2022/01/13/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%9703/</url>
    
    <content type="html"><![CDATA[<h1 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h1><p>&emsp;&emsp;大数乘法是基于大数加法的算法，大致思路如下：</p><p>&emsp;&emsp;将两个数的其中一个数的每个位数依次乘以另外那个数的各个位数，再将得到的各个结果相加（这里就要用到上一节大数的加法了）。</p><p><strong>例1：</strong> 以字符串的形式读入两个数字，编写一个函数计算它们的乘积，以字符串形式返回。</p><p>数据范围： 读入的数字大小满足 0≤n≤10的1000次方</p><p>要求：空间复杂度 O(n)，时间复杂度 O(n^2)</p><p><strong>答案与解析：</strong> </p><pre><code>class Solution &#123;public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *      * @param s string字符串 第一个整数     * @param t string字符串 第二个整数     * @return string字符串     */     string add(string s, string t) &#123;         if (s.size() == 0) return t;         if (t.size() == 0) return s;         int n = max(s.size(), t.size()) + 1, ind1 = s.size() - 1, ind2 = t.size() - 1, carry = 0;         string result(n, &#39;0&#39;);         for (int i = n - 1; i &gt;= 0; --i) &#123;             int x = ind1 &gt;= 0 ? s[ind1] - &#39;0&#39; : 0;             int y = ind2 &gt;= 0 ? t[ind2] - &#39;0&#39; : 0;             int sum = x + y + carry;             carry = sum / 10;             sum %= 10;             result[i] = sum + &#39;0&#39;;             --ind1;             --ind2;             &#125;             if (result[0] == &#39;0&#39;) return result.substr(1);             return result;             &#125;    //以上就是大数的加法运算，这里不做过多解释    string solve(string s, string t) &#123;        if (s == &quot;0&quot; || t == &quot;0&quot;) return &quot;0&quot;;//如果两数中有任意一个数为0；那么结果就是0        string result = &quot;0&quot;;        for (int i = t.size() - 1; i &gt;= 0; i--) &#123;//外层循环：目的在于取其中一个数的各个位数进行下一步的运算            string temp;//用于装载每个位数乘完另一个大数后的结果            int carry = 0;//代表进位数            for (int j = t.size() - 1; j &gt; i; j--) temp += &quot;0&quot;;//这里就是乘法运算的特点了，第一个数的第几位去乘另外一个数，那么相加时末尾就要空出几位（这里不妨用草稿纸笔画一下）            int b = t[i] - &#39;0&#39;;//取第一个数的每个位数            for (int j = s.size() - 1; j &gt;= 0; j--) &#123;//内层循环：目的在于取另外一个数的各个位数与第一个数的特定位数进行相乘                int a = s[j] - &#39;0&#39;;//取另外一个数的每个位数                int product = a * b + carry;                temp += product % 10 + &#39;0&#39;;//保存计算后的每位数                carry = product / 10;//得到新的进位数            &#125;            if (carry != 0)            &#123;                temp += carry+&#39;0&#39;;            &#125;//考虑到最高位还没有进位            reverse(temp.begin(), temp.end());//之前是反方向输出的结果，这里进行倒过来            result = add(result, temp);//执行大数相加操作，得到最终结果        &#125;        return result;    &#125;&#125;;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大数运算02</title>
    <link href="/2022/01/13/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%9702/"/>
    <url>/2022/01/13/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%9702/</url>
    
    <content type="html"><![CDATA[<h1 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h1><p><strong>例1：</strong> 以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。</p><p>数据范围：len(s),len(t)≤100000，字符串仅由’0’~‘9’构成。</p><p>要求：时间复杂度 O(n)。</p><p><strong>答案及解析：</strong></p><p>&emsp;&emsp;大数的运算一个最基本的思想就是把的大数的每个位数放入数组中，进行每位数计算，每位数的计算结果再放入新的数组中，连起来作为最终结果。</p><p>&emsp;&emsp;大数的加法这里很重要的一个点就是要定义一个进位数carry，每次都要考虑与进位数进行相加以及产生新的进位数。</p><p>&emsp;&emsp;本题用到的是String这个容器，String本身也有数组的某些性质，例如可以用下标的方式来访问字符串的每个字符，也具有其独特的某些性质，例如可以快速初始化、可以快速增删改查等等，具体将在《Sting容器》中讲解，下面看代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    /**</span><br><span class="line">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line">     * 计算两个数之和</span><br><span class="line">     * @param s string字符串 表示第一个整数</span><br><span class="line">     * @param t string字符串 表示第二个整数</span><br><span class="line">     * @return string字符串</span><br><span class="line">     */</span><br><span class="line">    string solve(string s, string t) &#123;</span><br><span class="line">        if (s.size() == 0) return t;</span><br><span class="line">        if (t.size() == 0) return s;//如果两数中有一个为0（及有一个字符串为空），则直接返回另外一个字符串</span><br><span class="line">        int n = max(s.size(), t.size()) + 1, ind1 = s.size() - 1, ind2 = t.size() - 1, carry = 0;</span><br><span class="line">        string ans(n, &#x27;0&#x27;);//预留好和值的最大可能位数，并先将每位初始化为0</span><br><span class="line">        for (int i = n - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            int x = ind1 &gt;= 0 ? s[ind1] - &#x27;0&#x27; : 0;</span><br><span class="line">            int y = ind2 &gt;= 0 ? t[ind2] - &#x27;0&#x27; : 0;//依次取每位上的字符数，并将其转化为整型数字用于计算</span><br><span class="line">            int sum = x + y + carry;</span><br><span class="line">            carry = sum / 10;//大数运算中必不可少的进位数</span><br><span class="line">            sum %= 10;</span><br><span class="line">            ans[i] = sum + &#x27;0&#x27;;//将运算后的每位上的整型数重新转化为字符型</span><br><span class="line">            --ind1;</span><br><span class="line">            --ind2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ans[0] == &#x27;0&#x27;) return ans.substr(1);//如果最高位没有进位，也就是说预留的位数多出一位，通过substr()方法去掉第一位0</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大数运算01</title>
    <link href="/2022/01/12/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%9701/"/>
    <url>/2022/01/12/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%9701/</url>
    
    <content type="html"><![CDATA[<h1 id="字符数字转化为整型数字"><a href="#字符数字转化为整型数字" class="headerlink" title="字符数字转化为整型数字"></a>字符数字转化为整型数字</h1><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><p><strong>‘字符’ - ‘0’</strong> ,举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a=&#x27;5&#x27;,b=&#x27;0&#x27;;</span><br><span class="line">int c=a-b;</span><br><span class="line">cout&lt;&lt; c &lt;&lt;endl; //结果输出5</span><br></pre></td></tr></table></figure><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>&emsp;&emsp;字符相加减实际上就是该字符所对应的ASK码相加减，<strong>数字的ASK码是按照顺序来规定的</strong>，‘0’到‘9’的ASK码值依次是48到58；因此他们ASK码的差值恰好等于自身的数值，我们这里再用一个整形数去接收它，就能成功实现将字符数字转化为整型数字了。</p><h2 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h2><p>&emsp;&emsp;在大数运算的算法类型中经常会出现由字符串作为输入值的算法题，那么怎么将字符串的各个字符传化为数字进行运算是破解该类型题的第一步。举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str=&quot;453547&quot;;</span><br><span class="line">int i;</span><br><span class="line">cin&gt;&gt;i; //i&lt;str.size()-1;</span><br><span class="line">int x=str[i]-&#x27;0&#x27;; //将第i个字符数字转化为整型数字</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法随想</title>
    <link href="/2022/01/12/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3/"/>
    <url>/2022/01/12/%E7%AE%97%E6%B3%95%E9%9A%8F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="算法随想"><a href="#算法随想" class="headerlink" title="算法随想"></a>算法随想</h1><h2 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a>什么是算法？</h2><p>&emsp;&emsp;广义上讲，算法就是“达成某种目的的步骤”,在计算机界，我们将通过数据处理、数值运算、组合计算、模拟等操作解决问题的步骤成为算法。严格来说，算法是一种<strong>具有明确定义的规则</strong>，能针对问题进行正确输出并停止。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
